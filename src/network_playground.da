# type: ignore
from utils import getObjectFromPath
from object_types import MsgType
from logger_util import LOGGER


class NetworkPlayground(process):
    def setup(scenario_executor_pid, number_of_nodes: int, number_of_twins: int, scenario, node_number_to_pid_mapping, pid_to_node_number_mapping, node_to_twin, twin_to_node):
        # self.rounds = len(getObjectFromPath(scenario, 'partitions'))
        # output("########", LOGGER.networkPlayground)
        # LOGGER.np = self
        # output("########", LOGGER.networkPlayground)
        self.scenario = scenario
        self.rounds = len(scenario['leaders'])-3
        self.commit_config = dict()
        self.node_number_to_pid_mapping = node_number_to_pid_mapping
        self.done_flag = False
        self.pid_to_node_number_mapping = pid_to_node_number_mapping
        self.scenario_executor_pid = scenario_executor_pid
        # output(self.node_number_to_pid_mapping)
        # output(self.pid_to_node_number_mapping)

    ##################   Helper functions   ##################

    ''' returns True if node_number present in twin_to_node else return False '''
    def is_twin(node_number):
        return node_number in self.twin_to_node

    ''' returns the twin of node if it exists else None '''
    def get_twin(node_num):
        return getObjectFromPath(self.node_to_twin, node_num)

    ''' returns the round number of message based on message type (proposal | vote | timeout) '''
    def get_msg_round(msg, msg_type):
        if msg_type == MsgType.Proposal:
            return msg.block.round
        elif msg_type == MsgType.Vote:
            return msg.vote_info.round
        elif msg_type == MsgType.Timeout:
            return msg.tmo_info.round

    ''' return partitions for all rounds for given msg type '''
    def get_partitions_for_msg_type(msg_type):
        if msg_type == MsgType.Proposal:
            return getObjectFromPath(self.scenario, 'proposal_partitions')
        elif msg_type == MsgType.Vote:
            return getObjectFromPath(self.scenario, 'vote_partitions')
        elif msg_type == MsgType.Timeout:
            return getObjectFromPath(self.scenario, 'timeout_partitions')

    ''' return partition for given round in which node p is present '''
    def get_partition(partitions_in_round, node):
        for partition in partitions_in_round:
            if node in partition:
                return partition.copy()
        return []

    ''' If the node p is a twin, then message should appear as though it was sent by the actual node, and not the twin '''
    def replace_with_twin_if_needed(node):
        actual_sender = node

        if self.is_twin(node):
            actual_sender = self.twin_to_node[node]
        return actual_sender

    ''' sends the msg to the appropriate nodes, attaching sender node in message '''
    def send_to_nodes(msg_name, node_nums_to_send, msg, sender):
        node_pids = []
        for node_num in node_nums_to_send:
            # print("Reaching here")
            node_pids.append(getObjectFromPath(
                self.node_number_to_pid_mapping, node_num))
        if node_pids:
            # output("sending ", msg_name, " to ", node_pids, "from ", sender)
            send((msg_name, msg, sender), to=node_pids)

    ##########################################################

    ##################   Receive Handlers   ##################

    def receive(msg=('Proposal', proposal_msg), from_=msg_sender):

        msg_sender_number = self.pid_to_node_number_mapping[msg_sender]

        msg_round = self.get_msg_round(proposal_msg, MsgType.Proposal)
        # get partitions for current message type and round
        all_partitions = self.get_partitions_for_msg_type(MsgType.Proposal)[
            msg_round-1]
        ''' if msg_round exceeds even the over estimated round, ignore '''
        if msg_round >= self.rounds + 3:
            output("Proposal Sending quit process")
            # output(parent(), type(parent()))
            # output(self.scenario_executor_pid,
            #    type(self.scena?rio_executor_pid))
            send(('Quit Process'), to=self.scenario_executor_pid)
            return

        ''' When current round is after self.rounds, there is only one partition with all the nodes '''
        if msg_round > self.rounds:
            # no notion of partitions in this round, i.e. all nodes present in the same partition

            # sender node will be updated if it is a twin
            actual_sender_node = self.replace_with_twin_if_needed(
                msg_sender_number)

            # broadcast messages to all nodes in the system

            destination_nodes = set()
            for partition in all_partitions:
                destination_nodes.update(partition)
            output("Sending proposal from ", msg_sender_number,
                   " to ", destination_nodes, "in round ", msg_round)
            self.send_to_nodes('Proposal', list(destination_nodes),
                               proposal_msg, actual_sender_node)
            return

        ''' When msg_round <= rounds, create partitions according to the scenario '''
        # get all nodes in partition to form list_of_validators_to_send_to
        destination_nodes = self.get_partition(
            all_partitions, msg_sender_number)
        # sender node will be updated if it is a twin
        actual_sender_node = self.replace_with_twin_if_needed(
            msg_sender_number)
        output("Sending proposal from ", msg_sender_number,
               " to ", destination_nodes, "in round ", msg_round)
        # send msg to all nodes in partition with the correct sender_node
        self.send_to_nodes('Proposal', destination_nodes,
                           proposal_msg, actual_sender_node)

    def receive(msg=('Vote', vote_msg, destination_node_num), from_=msg_sender):
        msg_round = self.get_msg_round(vote_msg, MsgType.Vote)
        destination_nodes = set()
        msg_sender_number = self.pid_to_node_number_mapping[msg_sender]
        all_partitions = self.get_partitions_for_msg_type(MsgType.Vote)[
            msg_round-1]
        ''' if msg_round exceeds even the over estimated round, ignore '''
        if msg_round >= self.rounds + 3:
            send(('Quit Process'), to=self.scenario_executor_pid)
            return

        ''' When current round is after self.rounds, there is only one partition with all the nodes '''
        if msg_round > self.rounds:
            # no notion of partitions in this round, i.e. all nodes present in the same partition

            ''' unicast message to destination node of msg '''
            actual_sender_node = self.replace_with_twin_if_needed(
                msg_sender_number)

            destination_nodes.add(destination_node_num)

            ''' If destination node has twin, then message should be sent to twin as well '''
            if self.get_twin(destination_node_num) is not None:
                destination_nodes.add(self.get_twin(destination_node_num))
            output("Sending vote from ", msg_sender_number,
                   " to ", destination_nodes, "in round ", msg_round)
            self.send_to_nodes('Vote', list(destination_nodes),
                               vote_msg, actual_sender_node)
            return

        ''' unicast message to destination node of msg '''
        # get all nodes in partition
        node_nums_in_partition = get_partition(
            all_partitions, msg_sender_number)
        # if destination node of msg is present in the same partition
        if destination_node_num in node_nums_in_partition:
            # add this node to final list of destination nodes
            destination_nodes.add(destination_node_num)

        if self.get_twin(destination_node_num) is not None and self.get_twin(destination_node_num) in node_nums_in_partition:
            # add twin of the node to final list of destination nodes
            destination_nodes.add(self.get_twin(destination_node_num))

        # sender node will be updated if it is a twin
        actual_sender_node = self.replace_with_twin_if_needed(
            msg_sender_number)
        output("Sending vote from ", msg_sender_number,
               " to ", destination_nodes, "in round ", msg_round)
        # send msg to all destination nodes in partition with the correct sender_node
        self.send_to_nodes('Vote', destination_nodes,
                           vote_msg, actual_sender_node)

    # def receive(msg=('Timeout', timeout_msg), from_=msg_sender):
    #     msg_round = self.get_msg_round(timeout_msg, MsgType.Timeout)
    #     msg_sender_number = self.pid_to_node_number_mapping[msg_sender]
    #     all_partitions = self.get_partitions_for_msg_type(MsgType.Timeout)[
    #         msg_round-1]
    #     if msg_round >= self.rounds + 3:
    #         send(('Quit Process'), to=self.scenario_executor_pid)
    #         return
    #     else:
    #         # no notion of partitions in this round, i.e. all nodes present in the same partition

    #         # sender node will be updated if it is a twin
    #         actual_sender_node = self.replace_with_twin_if_needed(
    #             msg_sender_number)
    #         # broadcast messages to all nodes in the system
    #         destination_nodes = set()
    #         for partition in all_partitions:
    #             destination_nodes.update(partition)
    #         self.send_to_nodes('Timeout', list(destination_nodes),
    #                            timeout_msg, actual_sender_node)
    #         return

    def receive(msg=('Timeout', timeout_msg), from_=msg_sender):

        msg_round = self.get_msg_round(timeout_msg, MsgType.Timeout)
        msg_sender_number = self.pid_to_node_number_mapping[msg_sender]
        # output("RECEIVED TIMEOUT FROM ", msg_sender_number)
        # get partitions for current message type and round
        all_partitions = self.get_partitions_for_msg_type(MsgType.Timeout)[
            msg_round-1]
        # output(all_partitions)
        ''' if msg_round exceeds even the over estimated round, ignore '''
        if msg_round >= self.rounds + 3:
            output("Timeout Sending quit process")
            # output(scenario_exector_pid)
            send(('Quit Process'), to=self.scenario_executor_pid)
            return

        ''' When current round is after self.rounds, there is only one partition with all the nodes '''
        if msg_round > self.rounds:
            # no notion of partitions in this round, i.e. all nodes present in the same partition

            # sender node will be updated if it is a twin
            actual_sender_node = self.replace_with_twin_if_needed(
                msg_sender_number)
            # broadcast messages to all nodes in the system
            destination_nodes = set()
            for partition in all_partitions:
                destination_nodes.update(partition)
            # output("SENDING TIMEOUT To ", destination_nodes)

            # output("Sending timeout from ", msg_sender_number,
            #        " to ", destination_nodes, "in round ", msg_round)
            self.send_to_nodes('Timeout', list(destination_nodes),
                               timeout_msg, actual_sender_node)
            return

        ''' When msg_round <= rounds, create partitions according to the scenario '''
        # get all nodes in partition to form list_of_validators_to_send_to

        destination_nodes = self.get_partition(
            all_partitions, msg_sender_number)
        # output("SENDING TIMEOUT To ", destination_nodes)

        # sender node will be updated if it is a twin
        actual_sender_node = self.replace_with_twin_if_needed(
            msg_sender_number)
        # output("Sending timeout from ", msg_sender_number,
        #        " to ", destination_nodes, "in round ", msg_round)
        # send msg to all nodes in partition with the correct sender_node
        self.send_to_nodes('Timeout', destination_nodes,
                           timeout_msg, actual_sender_node)

    def receive(msg=('Stop Network Playground'), from_=se):
        output("Stopping")
        exit()
        output("Stopped")

    def receive(msg=('Sync up required', past_round, current_round), from_=msg_sender):
        destination_nodes = list(self.pid_to_node_number_mapping.keys())
        destination_nodes.remove(msg_sender)
        # msg_sender_number = self.pid_to_node_number_mapping[msg_sender]
        # actual_sender = self.replace_with_twin_if_needed(
        #     msg_sender_number)
        send(('Sync up needed', past_round, current_round, msg_sender
              ), to=destination_nodes)

        # def receive(msg=('Done',), from_=scenario_executor):
        #     self.send_to_nodes()
        #     send commmit config to scenario ...
        #     pass

        ##########################################################

    def receive(msg=("Sync up proposals", proposal_map, requester),
                from_=msg_sender):
        send(("Sync up proposals", proposal_map, msg_sender),
             to=requester)

    def receive(msg=("Done sync up"), from_=p):
        destination_nodes = list(self.pid_to_node_number_mapping.keys())
        destination_nodes.remove(p)
        send(("Done sync up", p), to=destination_nodes)

    def receive(msg=("Kindly sync up", to_round, behind_node), from_=msg_sender):
        destination = []
        destination.append(self.node_number_to_pid_mapping[behind_node])
        if behind_node in self.node_to_twin:
            destination.append(
                self.node_number_to_pid_mapping[self.node_to_twin[behind_node]])
        # output("sending sync up request to ", destination)
        send(("Kindly sync up", to_round), to=destination)

    def run():
        output("Network playground running")
        # start timer here? or in setup itself?
        while not self.done_flag:
            # receive what messages exactly?

            if await(received(('Done',), from_=self.scenario_executor_pid)):
                self.done_flag = True

            # if await(receive(msg, destinations)):
            #     pass
            # elif timeout(6):
            #     output("Liveness violated")
            #     done_flag = True
