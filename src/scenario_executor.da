# type:ignore
from config import configs
from config_test_generator import config_tests
from ScenarioGenerator import ScenarioGenerator
import sys
import json
from logger_util import LOGGER
from validator import Validator
from cryptography import Cryptography
from network_playground import NetworkPlayground
import os
import shutil
from pprint import pprint


# dir_path = os.path.dirname(os.path.realpath(__file__))
# cwd = os.getcwd()
# sys.path.append(os.path.dirname(cwd)+'/config')
# print(sys.path)

SCENARIOS_FILE = "scenarios6.json"


class ScenarioExecutor(process):

    def setup(config, config_id, scenario, scenario_id):
        LOGGER.scenario_executor = self
        LOGGER.process_id = "scenario_executor"
        LOGGER.filename = '../logs/config' + str(config_id) + '/' \
            + '/scenario'+str(scenario_id)+'/' \
            + LOGGER.process_id + ".log"

        self.scenario = scenario
        self.scenario_id = scenario_id
        self.config = config
        self.config_id = config_id
        self.doneFlag = False
        # print(self.config_id)

    def run():

        nValidators = self.scenario['number_of_nodes']
        nTwins = self.scenario['number_of_twins']
        # current_scenario = scenario['scenario']
        # current_scenario = self.scenario
        # scenario variable initialization
        # self.nValidators = nValidators
        # self.nTwins = nTwins
        leaders = self.scenario['leaders']

        validator_private_keys = {}
        validator_public_keys = {}
        node_number_to_pid_mapping = {}
        pid_to_node_number_mapping = {}
        twin_to_node = {}
        node_to_twin = {}

        # output(nValidators)
        # output(nTwins)
        output(self.scenario)

        validators = new(Validator, num=nValidators)
        # twins = None
        # Create network playground object
        networkPlayground = new(NetworkPlayground, num=1)
        LOGGER.np = networkPlayground

        # Generate Validator keys
        for personal_id, validator in enumerate(validators):
            private_key, public_key = Cryptography.generate_key()
            validator_private_keys[personal_id] = private_key
            validator_public_keys[personal_id] = public_key
            node_number_to_pid_mapping[personal_id] = validator
            pid_to_node_number_mapping[validator] = personal_id

        # Setup the non-faulty validators
        for personal_id, validator in enumerate(validators):
            setup(validator, (self.config, self.config_id, self.scenario, self.scenario_id, personal_id, list(validators), validator_private_keys[personal_id], validator_public_keys,
                              leaders, networkPlayground, personal_id, self))

        # Define create_twins funtion
        # def create_twins():
        twins = new(Validator, num=nTwins)
        for personal_id, twin in enumerate(twins):
            setup(twin, (self.config, self.config_id, self.scenario, self.scenario_id, personal_id, list(validators), validator_private_keys[personal_id], validator_public_keys,
                         leaders, networkPlayground, personal_id+nValidators, self))
            twin_to_node[personal_id+nValidators] = personal_id
            node_to_twin[personal_id] = personal_id+nValidators
            node_number_to_pid_mapping[personal_id+nValidators] = twin
            pid_to_node_number_mapping[twin] = personal_id+nValidators

        # Create the twins
        # create_twins()

        # Setup network_playground
        setup(networkPlayground, (self, nValidators, nTwins, self.scenario,
                                  node_number_to_pid_mapping, pid_to_node_number_mapping, node_to_twin, twin_to_node, self.config_id, self.scenario_id))
        # output(twins)
        # Start all processes
        start(networkPlayground | twins | validators)
        LOGGER.log_action(
            'STARTED validators, twins and network playground', None)
        await(received(('Stop Processes',)))

        output("RECEIVED QUIT REQUEST")
        LOGGER.log_event('RECEIVED', 'QUIT REQUEST', {}, networkPlayground)

        send(('Stop Running',), to=validators | twins)

        await(self.doneFlag)

    def receive(msg=("forward commit config", commit_config), from_=np):
        send(('Ask main to end',), to=parent())
        output("Final ", commit_config)
        if safety_test(commit_config):
            output("Safety Upheld")
        else:
            output("Safety Violated")
        # output(commit_config)
        exit()
        # send(("done",), to=validators)
        # send(("done",), to=twins)
        # send(('done',), to=(validators | twins))
# send(('Quit Process'), to=self.scenario_executor_pid)

    def safety_test(commit_config):
        number_of_ledgers = len(commit_config)
        max_rounds = -1
        for ledger in commit_config:
            # print([ledger])
            max_rounds = max(max_rounds, len(commit_config[ledger]))
        # for c in commit_config:

        for r in range(max_rounds):
            curr = None
            for ledger in commit_config:
                if curr and r < len(commit_config[ledger]):
                    if curr != str(commit_config[ledger][r]):
                        output(curr, commit_config[ledger][r])
                        return False
                if not curr and r < len(commit_config[ledger]):
                    curr = str(commit_config[ledger][r])

        return True


def is_config_valid(config):
    if int(config['nvalidators']) < (3 * int(config['nfaulty']) + 1):
        print(
            "Number of validators should be more than thrice of number of faulty validators.")
        return False
    if (int(config['nfaulty']) > int(config['exclude_size'])) or (int(config['exclude_size']) > 2 * int(config['nfaulty'])):
        print(
            "Exlude size should be between nfaulty and 2*nfaulty")
        return False
    return True


def main():

    if os.path.exists('../logs/') and os.path.isdir('../logs/'):
        shutil.rmtree('../logs/')

    if os.path.exists('../ledgers/') and os.path.isdir('../ledgers/'):
        shutil.rmtree('../ledgers/')

    # TODO: Generate scenarios
    sg = ScenarioGenerator()
    sg.generate_scenario(
        number_of_nodes=config_tests["number_of_nodes"],
        number_of_twins=config_tests["number_of_twins"],
        rounds=config_tests["rounds"],
        number_of_partition=config_tests["number_of_partition"],
        leaders_only_faulty=config_tests["leaders_only_faulty"],
        number_of_partitions_pruned=config_tests["number_of_partitions_pruned"],
        selection_type_for_partitions=config_tests["selection_type_for_partitions"],
        number_of_partitions_leaders_pruned=config_tests["number_of_partitions_leaders_pruned"],
        selection_type_for_partitions_leaders_pruned=config_tests[
            "selection_type_for_partitions_leaders_pruned"],
        max_message_drops=config_tests["max_message_drops"],
        number_of_configs_pruned=config_tests["number_of_configs_pruned"],
        selection_type_for_configs_pruned=config_tests["selection_type_for_configs_pruned"],
        with_replacement=config_tests["with_replacement"],
    )
    config_id = 0
    for config in configs:
        os.makedirs('../logs/config' + str(config_id))
        os.makedirs('../ledgers/config' + str(config_id))
        # print(config)
        if not is_config_valid(config):
            #         # print("here")
            output("The provided config", config,
                   "is not valid. Skipping this config.")
            continue
        scenario_file = open(SCENARIOS_FILE)
        scenario_id = 0
        json_content = json.load(scenario_file)
        for each_scenario in json_content:
            os.makedirs('../logs/config' + str(config_id) +
                        '/scenario'+str(scenario_id))
            os.makedirs('../ledgers/config' + str(config_id) +
                        '/scenario'+str(scenario_id))
            scenario_executor = new(ScenarioExecutor, num=1)
            setup(scenario_executor, (config, config_id, each_scenario, scenario_id))
            start(scenario_executor)
            # await(some(received(("Next scenario",), from_=scenario_executor)))
            await(received(('Ask main to end',)))
            output("88888888888888888")
            scenario_id += 1
        config_id += 1
    exit()
