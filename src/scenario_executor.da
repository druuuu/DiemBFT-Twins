# type:ignore
from config import configs
import sys
import json
from validator import Validator
from cryptography import Cryptography
from network_playground import NetworkPlayground
import os
import shutil


# dir_path = os.path.dirname(os.path.realpath(__file__))
# cwd = os.getcwd()
# sys.path.append(os.path.dirname(cwd)+'/config')
# print(sys.path)
#


class ScenarioExecutor(process):
    def setup(config, config_id):
        self.stopped_processes = {}
        self.nValidators = None
        self.nTwins = None
        pass

    def run():

        os.makedirs('../logs/config' + str(config_id))
        os.makedirs('../ledgers/config' + str(config_id))

        # Load json file contents into a python dictionary 'json_content'
        scenario_file = open("scenario_test1.json")
        json_content = json.load(scenario_file)

        # For each scenario in json file, call execute_scenario
        for each_scenario in json_content["scenarios"]:
            self.nValidators = each_scenario['number_of_nodes']
            self.nTwins = each_scenario['number_of_twins']
            execute_scenario(each_scenario)
        output("REACHED END")

    def execute_scenario(scenario):

        nValidators = scenario['number_of_nodes']
        nTwins = scenario['number_of_twins']
        current_scenario = scenario['scenario']
        # scenario variable initialization
        self.nValidators = nValidators
        self.nTwins = nTwins
        self.stopped_processes = {}
        leaders = current_scenario['leaders']

        validator_private_keys = {}
        validator_public_keys = {}
        node_number_to_pid_mapping = {}
        pid_to_node_number_mapping = {}
        twin_to_node = {}
        node_to_twin = {}

        output(nValidators)
        output(nTwins)
        output(current_scenario)

        validators = new(Validator, num=nValidators)
        # twins = None
        # Create network playground object
        networkPlayground = new(NetworkPlayground, num=1)

        # Generate Validator keys
        for personal_id, validator in enumerate(validators):
            private_key, public_key = Cryptography.generate_key()
            validator_private_keys[personal_id] = private_key
            validator_public_keys[personal_id] = public_key
            node_number_to_pid_mapping[personal_id] = validator
            pid_to_node_number_mapping[validator] = personal_id

        # Setup the non-faulty validators
        for personal_id, validator in enumerate(validators):
            setup(validator, (config, config_id, personal_id, list(validators), validator_private_keys[personal_id], validator_public_keys,
                              leaders, networkPlayground, personal_id))

        # Define create_twins funtion
        # def create_twins():
        twins = new(Validator, num=nTwins)
        for personal_id, twin in enumerate(twins):
            setup(twin, (config, config_id, personal_id, list(validators), validator_private_keys[personal_id], validator_public_keys,
                         leaders, networkPlayground, personal_id+nValidators))
            twin_to_node[personal_id+nValidators] = personal_id
            node_to_twin[personal_id] = personal_id+nValidators
            node_number_to_pid_mapping[personal_id+nValidators] = twin
            pid_to_node_number_mapping[twin] = personal_id+nValidators

        # Create the twins
        # create_twins()

        # Setup network_playground
        setup(networkPlayground, (self, nValidators, nTwins, current_scenario,
                                  node_number_to_pid_mapping, pid_to_node_number_mapping, node_to_twin, twin_to_node))
        output(twins)
        # Start all processes
        start(networkPlayground | twins | validators)

        def receive(msg=('Quit process', p), from_=networkPlayground):
            if p not in self.stopped_processes:

                send(('Stop Running'), to=p)
                output("asked process ", p)
                self.stopped_processes[p] = True

            if len(self.stopped_processes) == self.nValidators + self.nTwins:

                send(("Stop Network Playground"), to=networkPlayground)
                # output("Stopping ")
                # exit()
        # output("stopped")
        # await()
        # start(twins)
        # start(validators)

        # TODO: await all process have been ended
        # TODO: send 'Done' to network_playground
        # TODO: stop the network_playground

        # Receive handler : Network Playground asks to quit process 'p'

    # TODO: Retrieve process and stop it (depends if p is personal_id or process_id)
    # TODO: Receive handler : Commit config
    # TODO: Safety check function


def is_config_valid(config):
    if int(config['nvalidators']) < (3 * int(config['nfaulty']) + 1):
        print(
            "Number of validators should be more than thrice of number of faulty validators.")
        return False
    if (int(config['nfaulty']) > int(config['exclude_size'])) or (int(config['exclude_size']) > 2 * int(config['nfaulty'])):
        print(
            "Exlude size should be between nfaulty and 2*nfaulty")
        return False
    return True


def main():

    if os.path.exists('../logs/') and os.path.isdir('../logs/'):
        shutil.rmtree('../logs/')

    if os.path.exists('../ledgers/') and os.path.isdir('../ledgers/'):
        shutil.rmtree('../ledgers/')

    # TODO: Generate scenarios

    config_id = 0
    for config in configs:
        # print(config)
        if not is_config_valid(config):
            # print("here")
            output("The provided config", config,
                   "is not valid. Skipping this config.")
            continue
        scenario_executor = new(ScenarioExecutor, num=1)
        setup(scenario_executor, (config, config_id))
        start(scenario_executor)
