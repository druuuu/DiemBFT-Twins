# type:ignore
from config import configs
import sys
import json
from validator import ValidatorFI
from cryptography import Cryptography
from network_playground import NetworkPlayground
import os
import shutil


# dir_path = os.path.dirname(os.path.realpath(__file__))
# cwd = os.getcwd()
# sys.path.append(os.path.dirname(cwd)+'/config')
# print(sys.path)
#


class ScenarioExecutor(process):
    def setup(config, config_id):
        pass

    def run():

        os.makedirs('../logs/config' + str(config_id))
        os.makedirs('../ledgers/config' + str(config_id))

        # Load json file contents into a python dictionary 'json_content'
        scenario_file = open("scenario_test1.json")
        json_content = json.load(scenario_file)

        # For each scenario in json file, call execute_scenario
        for each_scenario in json_content["scenarios"]:
            execute_scenario(each_scenario)

    def execute_scenario(scenario):

        nValidators = scenario['number_of_nodes']
        nTwins = scenario['number_of_twins']
        current_scenario = scenario['scenario']
        # scenario variable initialization
        leaders = current_scenario['leaders']

        validator_private_keys = {}
        validator_public_keys = {}
        scenario_number_mapping = {}
        twin_to_node = {}
        node_to_twin = {}

        output(nValidators)
        output(nTwins)
        output(current_scenario)

        validators = new(ValidatorFI, num=nValidators)
        twins = None
        # Create network playground object
        networkPlayground = new(NetworkPlayground, num=1)

        # Generate Validator keys
        for personal_id, validator in enumerate(validators):
            private_key, public_key = Cryptography.generate_key()
            validator_private_keys[personal_id] = private_key
            validator_public_keys[personal_id] = public_key
            scenario_number_mapping[personal_id] = validator

        # Setup the non-faulty validators
        for personal_id, validator in enumerate(validators):
            setup(validator, (config, config_id, personal_id, list(validators), validator_private_keys[personal_id], validator_public_keys,
                              leaders))

        # Define create_twins funtion
        def create_twins():
            twins = new(ValidatorFI, num=nTwins)
            for personal_id, twin in enumerate(twins):
                setup(twin, (config, config_id, personal_id, list(validators), validator_private_keys[personal_id], validator_public_keys,
                             leaders))
                twin_to_node[personal_id+nValidators] = personal_id
                node_to_twin[personal_id] = personal_id+nValidators
                scenario_number_mapping[personal_id+nValidators] = twin

        # Create the twins
        create_twins()

        # Setup network_playground
        setup(networkPlayground, (nValidators, nTwins, current_scenario,
                                  scenario_number_mapping, node_to_twin, twin_to_node))

        # Start all processes
        start(networkPlayground)
        start(validators)
        start(twins)

        # TODO: await all process have been ended
        # TODO: send 'Done' to network_playground
        # TODO: stop the network_playground

        # Receive handler : Network Playground asks to quit process 'p'
        def receive(msg=('Quit Process', p), from_=networkPlayground):
            pass
            # TODO: Retrieve process and stop it (depends if p is personal_id or process_id)

            # TODO: Receive handler : Commit config
            # TODO: Safety check function


def is_config_valid(config):
    if int(config['nvalidators']) < (3 * int(config['nfaulty']) + 1):
        print(
            "Number of validators should be more than thrice of number of faulty validators.")
        return False
    if (int(config['nfaulty']) > int(config['exclude_size'])) or (int(config['exclude_size']) > 2 * int(config['nfaulty'])):
        print(
            "Exlude size should be between nfaulty and 2*nfaulty")
        return False
    return True


def main():

    if os.path.exists('../logs/') and os.path.isdir('../logs/'):
        shutil.rmtree('../logs/')

    if os.path.exists('../ledgers/') and os.path.isdir('../ledgers/'):
        shutil.rmtree('../ledgers/')

    # TODO: Generate scenarios

    config_id = 0
    for config in configs:
        # print(config)
        if not is_config_valid(config):
            # print("here")
            output("The provided config", config,
                   "is not valid. Skipping this config.")
            continue
        scenario_executor = new(ScenarioExecutor, num=1)
        setup(scenario_executor, (config, config_id))
        start(scenario_executor)
